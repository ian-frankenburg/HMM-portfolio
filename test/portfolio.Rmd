---
title: "allocation"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r cars}
library(quantmod)
library(PerformanceAnalytics)
library(knitr)
library(ggplot2)
library(tidyverse)
library(tidyquant)
library(timetk)
# The symbols vector holds our tickers. 
symbols <- c("SPY","EFA", "IJS", "EEM","AGG")

# The prices object will hold our raw price data throughout this book.
prices <- 
  getSymbols(symbols, src = 'yahoo', from = "2005-01-01", 
             auto.assign = TRUE, warnings = FALSE) %>% 
  map(~Ad(get(.))) %>% 
  reduce(merge) %>%
  `colnames<-`(symbols)

prices_monthly <- to.monthly(prices, indexAt = "last", OHLC = FALSE)
asset_returns_xts <- na.omit(Return.calculate(prices_monthly, method = "log"))

asset_returns_long <- 
  prices %>% 
  to.monthly(indexAt = "last", OHLC = FALSE) %>% 
  tk_tbl(preserve_index = TRUE, rename_index = "date") %>%
  gather(asset, returns, -date) %>% 
  group_by(asset) %>%  
  mutate(returns = (log(returns) - log(lag(returns))))
```

https://rviews.rstudio.com/2017/10/11/from-asset-to-portfolio-returns/

Page 373 in *Finite Mixtures & Markov Swiching Models* to derive posterior predictive density. Then use this and apply page 101 in *Bayesian Methods in Finance* book to construct portfolio and efficient frontier.

To form the posterior predictive distribution of next week's returns, I first work with the one-step-ahead predictive density -- a byproduct of the filter/smoothing updating equations. From this, I'll get the posterior predictive density (unconditional on model parameters) by integrating out $\Theta$ and the latent hidden state $S_{1:T$.

The posterior predictive density then becomes
$$
\begin{align}
p(r_{T+1}|r_{1:T}) &= \int p(r_{T+1}|r_{1:T}, \Theta, S_{1:T})d\Theta dS_{1:T}\\
\end{align}
$$
The Monte Carlo sampling routine to draw from this distribution is as follows from section 12.4.2:

1. Draw $\Theta^{(s)}, S_{1:T}^{(s)}\sim p(\Theta, S_{1:T}|r_{1:T})$
2. Draw $S_{T+1}\sim p(S_{T+1}|S_T^{(s)}, \Theta^{(s)})$
2. Draw $r_{T+1}^{(s)} \sim p(r_{T+1}|r_{1:T}, \Theta^{(s)}, S_{T+1}^{(s)})$
3. Repeat 1-3 to form a collection of iid random draws from predictive density $p(r_{T+1}|r_{1:T})$

From this predictive distribution, various optimization routines may be employed for portfolio allocation or counter factual scenarios considered based upon distributional quantiles.



```{r backtest}
sampler = function(y){
  r <- NULL
  attempt <- 1
  while( is.null(r) && attempt <= 25 ) {
    attempt <- attempt + 1
    try(
       r <- gibbs(niter = 5000, burnin = 2500,
                      y = y, Sigma0 = Sigma00, v0 = v00, mu0 = mu00, S0 = S00)
    )
  }
  return(r)
}

p = ncol(asset_returns_xts)
mu00 = cbind(rep(0, p), rep(0, p))
v00 = c(15, 15)
Sigma00 = array(diag(p), dim=c(p,p,2))
S00 = abind::abind(diag(p), diag(p), along = 3)

start = which(format(as.Date(rownames(as.data.frame(asset_returns_xts))), "%Y")=="2010")[1]
forecast = nrow(y)-start
y_walking = y[1:start,]
weights = matrix(0, nrow=ncol(y), ncol = nrow(y))
m = .05
for(j in 1:forecast){
  fit = sampler(y_walking)
  # determine current regime
  regimes = apply(fit$filter, 1:2, mean)
  current_regime = which.max(regimes[nrow(regimes),])
  
  if(current_regime==1){
    mu = colMeans(fit$mu0_save)
    Sigma_t = apply(fit$Sigma0_save,1:2,mean)
  }else{
    mu = colMeans(fit$mu1_save)
    Sigma_t = apply(fit$Sigma1_save,1:2,mean)
  }
  w = solve(Sigma_t) %*% (m*)
  # calculate weights based on current regime

  # calculate returns based on weights
  returns[j] = w %*% t(monthly[months[j],])

  # save weight trajectories
  weights[,j] = w
  # jump one month ahead and refit HMM
  y_walking  = y[1:(start+j)]
}

y = apply(asset_returns_xts, 2, scale)
{
ptm <- Sys.time(); fit = sampler(y); print(Sys.time() - ptm)
regimes = apply(fit$filter, 1:2, mean)
par(mar=c(10,5,1,1))
matplot(regimes,type="l", axes=F)
axis(2)
axis(side=1,at=1:nrow(y),labels=rownames(as.data.frame(asset_returns_xts)), las=2)
}
plot(apply(regimes,1,which.max), type="l")
```

```{r}
rowMeans(fit$mu0_save)
rowMeans(fit$mu1_save)

matplot(apply(fit$filter, 1:2, median), type="l")

heatmap(cov2cor(apply(fit$Sigma1_save,1:2,mean)), Rowv = NA, Colv = NA)
heatmap(cov2cor(apply(fit$Sigma0_save,1:2,mean)), Rowv = NA, Colv = NA)

for(i in 1:p){
  hist(fit$mu0_save[i,], breaks=100, xlim=c(-5,5), col="darkred")
  hist(fit$mu1_save[i,], breaks=100, xlim=c(-5,5), col="darkblue", add=T)
}
plot(rowMeans(apply(fit$mu0_save, 1:2, mean)), pch=19, col="darkblue", ylim = c(-4,4))
points(apply(fit$mu0_save,1, quantile, .975), pch="-", col="darkblue")
points(apply(fit$mu0_save,1, quantile, .025), pch="-", col="darkblue")

points(rowMeans(apply(fit$mu1_save, 1:2, mean)), pch=19, col="darkred", ylim = c(-4,4))
points(apply(fit$mu1_save,1, quantile, .975), pch="-", col="darkred")
points(apply(fit$mu1_save,1, quantile, .025), pch="-", col="darkred")
```
